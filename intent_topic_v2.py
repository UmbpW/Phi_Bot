# intent_topic_v2.py — PATCH E + E1.1: Topic Gate V2
# Расширенные списки — чтобы не добавлять по одному слову при каждом новом кейсе
import re
from functools import lru_cache

# Имена философов, школ, направлений
TOPIC_PREFIXES = [
    "будд", "стоик", "экзист", "аристот", "сократ", "платон",
    "ницш", "конфуц", "кант", "гегел", "хайдег", "камю",
    "спиноз", "лейбниц", "юм", "локк", "декарт", "монтень",
]

# Широкие stems: темы, эпохи, концепты (любое слово, содержащее stem)
TOPIC_NOUNS = [
    # Философия и история идей
    "философи", "философ", "мыслител", "школ", "направлени", "течени",
    "традици", "концепц", "учени", "иде", "доктрин",
    # Эпохи и периоды
    "эпох", "возрождени", "античн", "средневеков", "просвещени", "современн",
    # Темы
    "бог", "смерт", "дружб", "любов", "деньг", "морал", "этик",
    "смысл", "страдан", "страх", "счаст", "добро", "зло", "свобод",
    "долг", "честь", "стыд", "вина", "истин", "познани",
]

# Универсальные паттерны: глагол запроса + «про/о» = topic (кроме «про меня/тебя»)
TOPIC_PATTERNS = [
    r"\b(какие бывают|какие есть|какие направления|какие школы)\b",
    r"\bкакие\b.*\b(философ\w*|школ\w*|направлени\w*|эпох\w*|традици\w*|течени\w*)\b",
    r"\b(опиши|объясни)\b.*(традици|концепц|школ|направлени|учени|будд)",
    r"\b(что такое|что значит|кто такие)\b\s+\w+",
    r"\b(расскажи|объясни|опиши|покажи|перечисли)(те)?\b.*\bпро\b(?!\s*(меня|тебя|себя)\b)",
    r"\b(расскажи|объясни|опиши|покажи)(те)?\b.*\b(о|об)\s+(философ|стоик|будд|иде)",
    r"\bкак\b\s+\w+\s+(смотрит|понимает|объясняет|думает)",
    r"\bкак\b\s+в\s+\w+",
    r"\b(существует ли|есть ли)\b\s+\w+",
    r"\bвзгляд\b\s+\w+\s+на",
]


def _normalize(text: str) -> str:
    """E1.1: unify with P1-style normalization."""
    t = (text or "").lower().replace("ё", "е")
    t = re.sub(r"\s+", " ", t).strip()
    return t


@lru_cache(maxsize=2048)
def topic_score(text: str) -> int:
    t = _normalize(text)
    score = 0

    for p in TOPIC_PREFIXES:
        if p in t:
            score += 2

    for n in TOPIC_NOUNS:
        if n in t:
            score += 1

    for pat in TOPIC_PATTERNS:
        if re.search(pat, t):
            score += 3

    return score


def is_topic_high(text: str) -> bool:
    return topic_score(text) >= 5


def is_topic_mid(text: str) -> bool:
    s = topic_score(text)
    return 3 <= s < 5
